// Code generated by protoc-gen-go. DO NOT EDIT.
// source: redisapp.proto

package redisapp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RequestFecha struct {
	Fecha                string   `protobuf:"bytes,1,opt,name=fecha,proto3" json:"fecha,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestFecha) Reset()         { *m = RequestFecha{} }
func (m *RequestFecha) String() string { return proto.CompactTextString(m) }
func (*RequestFecha) ProtoMessage()    {}
func (*RequestFecha) Descriptor() ([]byte, []int) {
	return fileDescriptor_redisapp_4358b1db0afc682a, []int{0}
}
func (m *RequestFecha) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestFecha.Unmarshal(m, b)
}
func (m *RequestFecha) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestFecha.Marshal(b, m, deterministic)
}
func (dst *RequestFecha) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestFecha.Merge(dst, src)
}
func (m *RequestFecha) XXX_Size() int {
	return xxx_messageInfo_RequestFecha.Size(m)
}
func (m *RequestFecha) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestFecha.DiscardUnknown(m)
}

var xxx_messageInfo_RequestFecha proto.InternalMessageInfo

func (m *RequestFecha) GetFecha() string {
	if m != nil {
		return m.Fecha
	}
	return ""
}

type RequestGif struct {
	Fecha                string   `protobuf:"bytes,1,opt,name=fecha,proto3" json:"fecha,omitempty"`
	Nombre               string   `protobuf:"bytes,2,opt,name=nombre,proto3" json:"nombre,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestGif) Reset()         { *m = RequestGif{} }
func (m *RequestGif) String() string { return proto.CompactTextString(m) }
func (*RequestGif) ProtoMessage()    {}
func (*RequestGif) Descriptor() ([]byte, []int) {
	return fileDescriptor_redisapp_4358b1db0afc682a, []int{1}
}
func (m *RequestGif) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestGif.Unmarshal(m, b)
}
func (m *RequestGif) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestGif.Marshal(b, m, deterministic)
}
func (dst *RequestGif) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGif.Merge(dst, src)
}
func (m *RequestGif) XXX_Size() int {
	return xxx_messageInfo_RequestGif.Size(m)
}
func (m *RequestGif) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGif.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGif proto.InternalMessageInfo

func (m *RequestGif) GetFecha() string {
	if m != nil {
		return m.Fecha
	}
	return ""
}

func (m *RequestGif) GetNombre() string {
	if m != nil {
		return m.Nombre
	}
	return ""
}

type Gif struct {
	Titulo               string   `protobuf:"bytes,1,opt,name=titulo,proto3" json:"titulo,omitempty"`
	Contenido            string   `protobuf:"bytes,2,opt,name=contenido,proto3" json:"contenido,omitempty"`
	Contador             int64    `protobuf:"varint,3,opt,name=contador,proto3" json:"contador,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Gif) Reset()         { *m = Gif{} }
func (m *Gif) String() string { return proto.CompactTextString(m) }
func (*Gif) ProtoMessage()    {}
func (*Gif) Descriptor() ([]byte, []int) {
	return fileDescriptor_redisapp_4358b1db0afc682a, []int{2}
}
func (m *Gif) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Gif.Unmarshal(m, b)
}
func (m *Gif) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Gif.Marshal(b, m, deterministic)
}
func (dst *Gif) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gif.Merge(dst, src)
}
func (m *Gif) XXX_Size() int {
	return xxx_messageInfo_Gif.Size(m)
}
func (m *Gif) XXX_DiscardUnknown() {
	xxx_messageInfo_Gif.DiscardUnknown(m)
}

var xxx_messageInfo_Gif proto.InternalMessageInfo

func (m *Gif) GetTitulo() string {
	if m != nil {
		return m.Titulo
	}
	return ""
}

func (m *Gif) GetContenido() string {
	if m != nil {
		return m.Contenido
	}
	return ""
}

func (m *Gif) GetContador() int64 {
	if m != nil {
		return m.Contador
	}
	return 0
}

func init() {
	proto.RegisterType((*RequestFecha)(nil), "redisapp.RequestFecha")
	proto.RegisterType((*RequestGif)(nil), "redisapp.RequestGif")
	proto.RegisterType((*Gif)(nil), "redisapp.Gif")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MicroClient is the client API for Micro service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MicroClient interface {
	// Devuelve el primer gif de una fecha enviada
	// Devuelve nil si no hay gif en esa fecha
	GetGif(ctx context.Context, in *RequestGif, opts ...grpc.CallOption) (*Gif, error)
	// Devuelve los top 10 gifs almacenados en redis
	Top10Gifs(ctx context.Context, in *RequestFecha, opts ...grpc.CallOption) (Micro_Top10GifsClient, error)
}

type microClient struct {
	cc *grpc.ClientConn
}

func NewMicroClient(cc *grpc.ClientConn) MicroClient {
	return &microClient{cc}
}

func (c *microClient) GetGif(ctx context.Context, in *RequestGif, opts ...grpc.CallOption) (*Gif, error) {
	out := new(Gif)
	err := c.cc.Invoke(ctx, "/redisapp.Micro/GetGif", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microClient) Top10Gifs(ctx context.Context, in *RequestFecha, opts ...grpc.CallOption) (Micro_Top10GifsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Micro_serviceDesc.Streams[0], "/redisapp.Micro/Top10Gifs", opts...)
	if err != nil {
		return nil, err
	}
	x := &microTop10GifsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Micro_Top10GifsClient interface {
	Recv() (*Gif, error)
	grpc.ClientStream
}

type microTop10GifsClient struct {
	grpc.ClientStream
}

func (x *microTop10GifsClient) Recv() (*Gif, error) {
	m := new(Gif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MicroServer is the server API for Micro service.
type MicroServer interface {
	// Devuelve el primer gif de una fecha enviada
	// Devuelve nil si no hay gif en esa fecha
	GetGif(context.Context, *RequestGif) (*Gif, error)
	// Devuelve los top 10 gifs almacenados en redis
	Top10Gifs(*RequestFecha, Micro_Top10GifsServer) error
}

func RegisterMicroServer(s *grpc.Server, srv MicroServer) {
	s.RegisterService(&_Micro_serviceDesc, srv)
}

func _Micro_GetGif_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGif)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroServer).GetGif(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redisapp.Micro/GetGif",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroServer).GetGif(ctx, req.(*RequestGif))
	}
	return interceptor(ctx, in, info, handler)
}

func _Micro_Top10Gifs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestFecha)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MicroServer).Top10Gifs(m, &microTop10GifsServer{stream})
}

type Micro_Top10GifsServer interface {
	Send(*Gif) error
	grpc.ServerStream
}

type microTop10GifsServer struct {
	grpc.ServerStream
}

func (x *microTop10GifsServer) Send(m *Gif) error {
	return x.ServerStream.SendMsg(m)
}

var _Micro_serviceDesc = grpc.ServiceDesc{
	ServiceName: "redisapp.Micro",
	HandlerType: (*MicroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGif",
			Handler:    _Micro_GetGif_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Top10Gifs",
			Handler:       _Micro_Top10Gifs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "redisapp.proto",
}

func init() { proto.RegisterFile("redisapp.proto", fileDescriptor_redisapp_4358b1db0afc682a) }

var fileDescriptor_redisapp_4358b1db0afc682a = []byte{
	// 215 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x90, 0x3f, 0x4b, 0xc5, 0x30,
	0x14, 0xc5, 0x8d, 0xe5, 0x85, 0xd7, 0x8b, 0x3a, 0x5c, 0xa4, 0x94, 0x87, 0x43, 0x09, 0x0e, 0x9d,
	0x6a, 0x55, 0x70, 0xf0, 0x03, 0x98, 0xc9, 0xa5, 0x08, 0xce, 0xfd, 0x93, 0x60, 0x40, 0x7b, 0x63,
	0x9a, 0x7e, 0x7f, 0x69, 0x1b, 0xdb, 0xa1, 0x6f, 0xcb, 0xef, 0x70, 0x7f, 0x70, 0x72, 0xe0, 0xc6,
	0xa9, 0xce, 0x0c, 0xb5, 0xb5, 0x85, 0x75, 0xe4, 0x09, 0x8f, 0xff, 0x2c, 0xee, 0xe1, 0xaa, 0x52,
	0xbf, 0xa3, 0x1a, 0xfc, 0x9b, 0x6a, 0xbf, 0x6a, 0xbc, 0x85, 0x83, 0x9e, 0x1e, 0x29, 0xcb, 0x58,
	0x1e, 0x57, 0x0b, 0x88, 0x57, 0x80, 0x70, 0x25, 0x8d, 0x3e, 0x7f, 0x83, 0x09, 0xf0, 0x9e, 0x7e,
	0x1a, 0xa7, 0xd2, 0xcb, 0x39, 0x0e, 0x24, 0x3e, 0x21, 0x9a, 0xa4, 0x04, 0xb8, 0x37, 0x7e, 0xfc,
	0xa6, 0x60, 0x05, 0xc2, 0x3b, 0x88, 0x5b, 0xea, 0xbd, 0xea, 0x4d, 0x47, 0xc1, 0xdc, 0x02, 0x3c,
	0xc1, 0x71, 0x82, 0xba, 0x23, 0x97, 0x46, 0x19, 0xcb, 0xa3, 0x6a, 0xe5, 0x27, 0x0b, 0x87, 0x77,
	0xd3, 0x3a, 0xc2, 0x07, 0xe0, 0x52, 0x2d, 0xcd, 0x8a, 0xf5, 0xa3, 0x5b, 0xdf, 0xd3, 0xf5, 0x96,
	0x4a, 0xa3, 0xc5, 0x05, 0xbe, 0x40, 0xfc, 0x41, 0xf6, 0xb1, 0x94, 0x46, 0x0f, 0x98, 0xec, 0x9c,
	0x79, 0x89, 0x9d, 0x55, 0xb2, 0x86, 0xcf, 0xeb, 0x3d, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x60,
	0x45, 0x0e, 0x0f, 0x4f, 0x01, 0x00, 0x00,
}
